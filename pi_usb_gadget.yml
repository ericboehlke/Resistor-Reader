---
- name: Prep Raspberry Pi Zero for USB gadget SSH over USB
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    bootfs_mount: /media/eric/bootfs     # Path where Pi boot (FAT) is mounted
    rootfs_mount: /media/eric/rootfs     # Path where Pi root (ext4) is mounted

    username: pi                         # User to create on first boot
    # Provide ONE of the following (or both):
    password: null                       # Plaintext password (optional)
    password_hash: null                  # SHA-512 hash (optional; overrides plaintext if set)
    ssh_public_key: null                 # Public key content for key login (optional)

    # Ownership for files on the rootfs (defaults match Raspberry Pi OS 'pi' user)
    user_uid: 1000
    user_gid: 1000

  tasks:
    ###########################################################################
    # Sanity checks
    ###########################################################################
    - name: Assert boot partition is mounted (cmdline.txt present)
      stat:
        path: "{{ bootfs_mount }}/cmdline.txt"
      register: bootfs_cmdline
    - name: Fail if bootfs not mounted correctly
      fail:
        msg: "cmdline.txt not found at {{ bootfs_mount }}. Mount the Pi boot partition or pass -e bootfs_mount=/path."
      when: not bootfs_cmdline.stat.exists

    - name: Assert root partition mount path exists (directory)
      stat:
        path: "{{ rootfs_mount }}"
      register: rootfs_dir
    - name: Fail if rootfs path missing
      fail:
        msg: "Root partition mount path {{ rootfs_mount }} does not exist. Mount /dev/sdX2 there or set -e rootfs_mount=/path."
      when: not rootfs_dir.stat.exists

    ###########################################################################
    # Enable USB device mode (dwc2) and g_ether
    ###########################################################################
    - name: Ensure dtoverlay=dwc2 is present in config.txt
      lineinfile:
        path: "{{ bootfs_mount }}/config.txt"
        regexp: '^\s*dtoverlay=dwc2\s*$'
        line: 'dtoverlay=dwc2'
        insertafter: EOF
        state: present
        create: no

    - name: Read current cmdline.txt (must remain a single line)
      slurp:
        path: "{{ bootfs_mount }}/cmdline.txt"
      register: cmdline_raw

    - name: Normalize cmdline to a single space-separated line
      set_fact:
        cmdline_str: "{{ (cmdline_raw.content | b64decode | regex_replace('\\s+', ' ') ).strip() }}"

    - name: Ensure modules-load=dwc2,g_ether is present in cmdline
      set_fact:
        cmdline_updated: >-
          {{
            (cmdline_str is search('modules-load=')) |
            ternary(
              cmdline_str | regex_replace('modules-load=[^\\s]+', 'modules-load=dwc2,g_ether'),
              cmdline_str ~ ' modules-load=dwc2,g_ether'
            )
          }}

    - name: Write updated cmdline.txt back (single line)
      copy:
        dest: "{{ bootfs_mount }}/cmdline.txt"
        content: "{{ cmdline_updated }}\n"
        mode: '0644'

    ###########################################################################
    # SSH enablement: file vs directory (authorized_keys)
    ###########################################################################
    - name: Enable SSH by creating 'ssh' file when NOT using key-based login
      file:
        path: "{{ bootfs_mount }}/ssh"
        state: touch
        mode: '0644'
      when: ssh_public_key is none

    - name: Check if /boot/ssh path exists (for key-based flow)
      stat:
        path: "{{ bootfs_mount }}/ssh"
      register: ssh_path
      when: ssh_public_key is not none

    - name: Remove /boot/ssh file if present (we will create a directory)
      file:
        path: "{{ bootfs_mount }}/ssh"
        state: absent
      when: ssh_public_key is not none and ssh_path.stat.exists and ssh_path.stat.isreg

    - name: Create /boot/ssh directory for key-based login
      file:
        path: "{{ bootfs_mount }}/ssh"
        state: directory
        mode: '0700'
      when: ssh_public_key is not none

    - name: Add authorized_keys for key-based login
      copy:
        dest: "{{ bootfs_mount }}/ssh/authorized_keys"
        content: "{{ ssh_public_key }}\n"
        mode: '0600'
      when: ssh_public_key is not none

    ###########################################################################
    # User creation via userconf.txt
    # If ANY of (password, password_hash, ssh_public_key) is provided,
    # we ensure the user exists on first boot.
    ###########################################################################
    - name: Hash plaintext password if provided (sha512)
      set_fact:
        final_password_hash: "{{ password | password_hash('sha512') }}"
      when: password is not none and password_hash is none

    - name: Use provided password_hash directly
      set_fact:
        final_password_hash: "{{ password_hash }}"
      when: password_hash is not none

    - name: Create userconf.txt if password OR key provided (ensures user exists)
      copy:
        dest: "{{ bootfs_mount }}/userconf.txt"
        content: "{{ username }}:{{ final_password_hash | default('$6$PLACEHOLDERHASH') }}\n"
        mode: '0600'
      when: password is not none or password_hash is not none or ssh_public_key is not none

    ###########################################################################
    # Rootfs tasks: ensure home and clone repo
    ###########################################################################
    - name: Ensure user home exists on rootfs
      file:
        path: "{{ rootfs_mount }}/home/{{ username }}"
        state: directory
        owner: "{{ user_uid }}"
        group: "{{ user_gid }}"
        mode: '0755'
      become: true
      become_user: root

    - name: Clone Resistor-Reader repo into user's home
      git:
        repo: "https://github.com/ericboehlke/Resistor-Reader.git"
        dest: "{{ rootfs_mount }}/home/{{ username }}/Resistor-Reader"
        version: master
        update: yes
      become: true
      become_user: root

    - name: Ensure repo ownership belongs to target user
      file:
        path: "{{ rootfs_mount }}/home/{{ username }}/Resistor-Reader"
        state: directory
        owner: "{{ user_uid }}"
        group: "{{ user_gid }}"
        recurse: true
      become: true
      become_user: root
